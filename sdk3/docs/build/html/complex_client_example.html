
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <title>Complex Client Example &#8212; Network Next SDK 3.4.5 documentation</title>
    <link rel="stylesheet" href="_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <script id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/doctools.js"></script>
    <script src="_static/language_data.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Complex Server Example" href="complex_server_example.html" />
    <link rel="prev" title="Upgraded Server Example" href="upgraded_server_example.html" />
   
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <div class="section" id="complex-client-example">
<h1>Complex Client Example<a class="headerlink" href="#complex-client-example" title="Permalink to this headline">¶</a></h1>
<p>In this example we build the kitchen sink version of a client where we show off all the features :)</p>
<p>We demonstrate:</p>
<ul class="simple">
<li><p>Setting the network next log level</p></li>
<li><p>Setting a custom log function</p></li>
<li><p>Setting a custom assert handler</p></li>
<li><p>Setting a custom allocator</p></li>
<li><p>Querying the port the client socket is bound to</p></li>
<li><p>Getting statistics from the client</p></li>
</ul>
<p>This is going to be a huge example, so let’s get started!</p>
<p>First, as with the upgraded client example, we start by defining our key configuration variables:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">bind_address</span> <span class="o">=</span> <span class="s">&quot;0.0.0.0:0&quot;</span><span class="p">;</span>
<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">server_address</span> <span class="o">=</span> <span class="s">&quot;127.0.0.1:50000&quot;</span><span class="p">;</span>
<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">customer_public_key</span> <span class="o">=</span> <span class="s">&quot;leN7D7+9vr24uT4f1Ba8PEEvIQA/UkGZLlT+sdeLRHKsVqaZq723Zw==&quot;</span><span class="p">;</span>
</pre></div>
</div>
<p>Next, we dive right in and define a custom allocator class that tracks all allocations made, and checks them for leaks when it shuts down:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">AllocatorEntry</span>
<span class="p">{</span>
    <span class="c1">// ...</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">Allocator</span>
<span class="p">{</span>
    <span class="kt">int64_t</span> <span class="n">num_allocations</span><span class="p">;</span>
    <span class="n">next_mutex_t</span> <span class="n">mutex</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">*</span><span class="p">,</span> <span class="n">AllocatorEntry</span><span class="o">*&gt;</span> <span class="n">entries</span><span class="p">;</span>

<span class="k">public</span><span class="o">:</span>

    <span class="n">Allocator</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="n">next_mutex_create</span><span class="p">(</span> <span class="o">&amp;</span><span class="n">mutex</span> <span class="p">);</span>
        <span class="n">next_assert</span><span class="p">(</span> <span class="n">result</span> <span class="o">==</span> <span class="n">NEXT_OK</span> <span class="p">);</span>
        <span class="n">num_allocations</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="o">~</span><span class="n">Allocator</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">next_mutex_destroy</span><span class="p">(</span> <span class="o">&amp;</span><span class="n">mutex</span> <span class="p">);</span>
        <span class="n">next_assert</span><span class="p">(</span> <span class="n">num_allocations</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">);</span>
        <span class="n">next_assert</span><span class="p">(</span> <span class="n">entries</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">);</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="o">*</span> <span class="n">Alloc</span><span class="p">(</span> <span class="kt">size_t</span> <span class="n">size</span> <span class="p">)</span>
    <span class="p">{</span>
        <span class="n">next_mutex_guard</span><span class="p">(</span> <span class="o">&amp;</span><span class="n">mutex</span> <span class="p">);</span>
        <span class="kt">void</span> <span class="o">*</span> <span class="n">pointer</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span> <span class="n">size</span> <span class="p">);</span>
        <span class="n">next_assert</span><span class="p">(</span> <span class="n">pointer</span> <span class="p">);</span>
        <span class="n">next_assert</span><span class="p">(</span> <span class="n">entries</span><span class="p">[</span><span class="n">pointer</span><span class="p">]</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="p">);</span>
        <span class="n">AllocatorEntry</span> <span class="o">*</span> <span class="n">entry</span> <span class="o">=</span> <span class="k">new</span> <span class="n">AllocatorEntry</span><span class="p">();</span>
        <span class="n">entries</span><span class="p">[</span><span class="n">pointer</span><span class="p">]</span> <span class="o">=</span> <span class="n">entry</span><span class="p">;</span>
        <span class="n">num_allocations</span><span class="o">++</span><span class="p">;</span>
        <span class="k">return</span> <span class="n">pointer</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">Free</span><span class="p">(</span> <span class="kt">void</span> <span class="o">*</span> <span class="n">pointer</span> <span class="p">)</span>
    <span class="p">{</span>
        <span class="n">next_mutex_guard</span><span class="p">(</span> <span class="o">&amp;</span><span class="n">mutex</span> <span class="p">);</span>
        <span class="n">next_assert</span><span class="p">(</span> <span class="n">pointer</span> <span class="p">);</span>
        <span class="n">next_assert</span><span class="p">(</span> <span class="n">num_allocations</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="p">);</span>
        <span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">*</span><span class="p">,</span> <span class="n">AllocatorEntry</span><span class="o">*&gt;::</span><span class="n">iterator</span> <span class="n">itor</span> <span class="o">=</span> <span class="n">entries</span><span class="p">.</span><span class="n">find</span><span class="p">(</span> <span class="n">pointer</span> <span class="p">);</span>
        <span class="n">next_assert</span><span class="p">(</span> <span class="n">itor</span> <span class="o">!=</span> <span class="n">entries</span><span class="p">.</span><span class="n">end</span><span class="p">()</span> <span class="p">);</span>
        <span class="n">entries</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span> <span class="n">itor</span> <span class="p">);</span>
        <span class="n">num_allocations</span><span class="o">--</span><span class="p">;</span>
        <span class="n">free</span><span class="p">(</span> <span class="n">pointer</span> <span class="p">);</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></div>
</div>
<p>IMPORTANT: Since this allocator will be called from multiple threads, it must be thread safe. This is done by using the platform independent mutex supplied by the Network Next SDK.</p>
<p>There are three types of allocations done by the Network Next SDK:</p>
<ol class="arabic simple">
<li><p>Global allocations</p></li>
<li><p>Per-client allocations</p></li>
<li><p>Per-server allocations</p></li>
</ol>
<p>Each of these situations corresponds to what is called a “context” in the Network Next SDK.</p>
<p>A context is simply a void* to a type that you define which is passed in to malloc and free callbacks that we call to perform allocations on behalf of the SDK. The context passed is gives you the flexibility to have a specific memory pool for Network Next (most common), or even to have a completely different allocation pool used for each client and server instance. That’s what we’re going to do in this example.</p>
<p>Let’s define a base context that will be used for global allocations:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">Context</span>
<span class="p">{</span>
    <span class="n">Allocator</span> <span class="o">*</span> <span class="n">allocator</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>And a per-client context that is binary compatible with the base context, to be used for per-client allocations:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">ClientContext</span>
<span class="p">{</span>
    <span class="n">Allocator</span> <span class="o">*</span> <span class="n">allocator</span><span class="p">;</span>
    <span class="kt">uint32_t</span> <span class="n">client_data</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>As you can see, the client context can contain additional information aside from the allocator. The context is not <em>just</em> passed into allocator callbacks, but to all callbacks from the client and server, so you can use it to integrate with your own client and server objects in your game.</p>
<p>Here we just put a dummy uint32_t in the client context and check its value to verify it’s being passed through correctly. For example, in the received packet callback, we have access to the client context and check the dummy value is what we expect:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">client_packet_received</span><span class="p">(</span> <span class="n">next_client_t</span> <span class="o">*</span> <span class="n">client</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span> <span class="n">_context</span><span class="p">,</span> <span class="k">const</span> <span class="kt">uint8_t</span> <span class="o">*</span> <span class="n">packet_data</span><span class="p">,</span> <span class="kt">int</span> <span class="n">packet_bytes</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="n">client</span><span class="p">;</span>

    <span class="n">ClientContext</span> <span class="o">*</span> <span class="n">context</span> <span class="o">=</span> <span class="p">(</span><span class="n">ClientContext</span><span class="o">*</span><span class="p">)</span> <span class="n">_context</span><span class="p">;</span>

    <span class="n">next_assert</span><span class="p">(</span> <span class="n">context</span> <span class="p">);</span>
    <span class="n">next_assert</span><span class="p">(</span> <span class="n">context</span><span class="o">-&gt;</span><span class="n">allocator</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="p">);</span>
    <span class="n">next_assert</span><span class="p">(</span> <span class="n">context</span><span class="o">-&gt;</span><span class="n">client_data</span> <span class="o">==</span> <span class="mh">0x12345</span> <span class="p">);</span>

    <span class="n">next_printf</span><span class="p">(</span> <span class="n">NEXT_LOG_LEVEL_INFO</span><span class="p">,</span> <span class="s">&quot;client received packet from server (%d bytes)&quot;</span><span class="p">,</span> <span class="n">packet_bytes</span> <span class="p">);</span>

    <span class="n">verify_packet</span><span class="p">(</span> <span class="n">packet_data</span><span class="p">,</span> <span class="n">packet_bytes</span> <span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Next we define custom malloc and free functions to pass in to the SDK. These same functions are used for global, per-client and per-server allocations. The only difference is the context passed in to each.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="o">*</span> <span class="nf">malloc_function</span><span class="p">(</span> <span class="kt">void</span> <span class="o">*</span> <span class="n">_context</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">bytes</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="n">Context</span> <span class="o">*</span> <span class="n">context</span> <span class="o">=</span> <span class="p">(</span><span class="n">Context</span><span class="o">*</span><span class="p">)</span> <span class="n">_context</span><span class="p">;</span>
    <span class="n">next_assert</span><span class="p">(</span> <span class="n">context</span> <span class="p">);</span>
    <span class="n">next_assert</span><span class="p">(</span> <span class="n">context</span><span class="o">-&gt;</span><span class="n">allocator</span> <span class="p">);</span>
    <span class="k">return</span> <span class="n">context</span><span class="o">-&gt;</span><span class="n">allocator</span><span class="o">-&gt;</span><span class="n">Alloc</span><span class="p">(</span> <span class="n">bytes</span> <span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">free_function</span><span class="p">(</span> <span class="kt">void</span> <span class="o">*</span> <span class="n">_context</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span> <span class="n">p</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="n">Context</span> <span class="o">*</span> <span class="n">context</span> <span class="o">=</span> <span class="p">(</span><span class="n">Context</span><span class="o">*</span><span class="p">)</span> <span class="n">_context</span><span class="p">;</span>
    <span class="n">next_assert</span><span class="p">(</span> <span class="n">context</span> <span class="p">);</span>
    <span class="n">next_assert</span><span class="p">(</span> <span class="n">context</span><span class="o">-&gt;</span><span class="n">allocator</span> <span class="p">);</span>
    <span class="k">return</span> <span class="n">context</span><span class="o">-&gt;</span><span class="n">allocator</span><span class="o">-&gt;</span><span class="n">Free</span><span class="p">(</span> <span class="n">p</span> <span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Moving past allocations for the moment, we set up a callback for our own custom logging function:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">extern</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="nf">log_level_string</span><span class="p">(</span> <span class="kt">int</span> <span class="n">level</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">level</span> <span class="o">==</span> <span class="n">NEXT_LOG_LEVEL_DEBUG</span> <span class="p">)</span>
        <span class="k">return</span> <span class="s">&quot;debug&quot;</span><span class="p">;</span>
    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span> <span class="n">level</span> <span class="o">==</span> <span class="n">NEXT_LOG_LEVEL_INFO</span> <span class="p">)</span>
        <span class="k">return</span> <span class="s">&quot;info&quot;</span><span class="p">;</span>
    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span> <span class="n">level</span> <span class="o">==</span> <span class="n">NEXT_LOG_LEVEL_ERROR</span> <span class="p">)</span>
        <span class="k">return</span> <span class="s">&quot;error&quot;</span><span class="p">;</span>
    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span> <span class="n">level</span> <span class="o">==</span> <span class="n">NEXT_LOG_LEVEL_WARN</span> <span class="p">)</span>
        <span class="k">return</span> <span class="s">&quot;warning&quot;</span><span class="p">;</span>
    <span class="k">else</span>
        <span class="k">return</span> <span class="s">&quot;???&quot;</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">log_function</span><span class="p">(</span> <span class="kt">int</span> <span class="n">level</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">format</span><span class="p">,</span> <span class="p">...</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="kt">va_list</span> <span class="n">args</span><span class="p">;</span>
    <span class="n">va_start</span><span class="p">(</span> <span class="n">args</span><span class="p">,</span> <span class="n">format</span> <span class="p">);</span>
    <span class="kt">char</span> <span class="n">buffer</span><span class="p">[</span><span class="mi">1024</span><span class="p">];</span>
    <span class="n">vsnprintf</span><span class="p">(</span> <span class="n">buffer</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span> <span class="n">buffer</span> <span class="p">),</span> <span class="n">format</span><span class="p">,</span> <span class="n">args</span> <span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">level</span> <span class="o">!=</span> <span class="n">NEXT_LOG_LEVEL_NONE</span> <span class="p">)</span>
    <span class="p">{</span>
        <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">level_string</span> <span class="o">=</span> <span class="n">log_level_string</span><span class="p">(</span> <span class="n">level</span> <span class="p">);</span>
        <span class="n">printf</span><span class="p">(</span> <span class="s">&quot;%.2f: %s: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">next_time</span><span class="p">(),</span> <span class="n">level_string</span><span class="p">,</span> <span class="n">buffer</span> <span class="p">);</span>
    <span class="p">}</span>
    <span class="k">else</span>
    <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span> <span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">buffer</span> <span class="p">);</span>
    <span class="p">}</span>
    <span class="n">va_end</span><span class="p">(</span> <span class="n">args</span> <span class="p">);</span>
    <span class="n">fflush</span><span class="p">(</span> <span class="n">stdout</span> <span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>There are four different log levels in Network Next:</p>
<ol class="arabic simple">
<li><p>NEXT_LOG_LEVEL_NONE (0)</p></li>
<li><p>NEXT_LOG_LEVEL_ERROR (1)</p></li>
<li><p>NEXT_LOG_LEVEL_INFO (2)</p></li>
<li><p>NEXT_LOG_LEVEL_WARN (3)</p></li>
<li><p>NEXT_LOG_LEVEL_DEBUG (4)</p></li>
</ol>
<p>The default log level is NEXT_LOG_LEVEL_INFO, which shows both info and error logs. This is a good default, as these messages are infrequent. Warnings can be more frequent, and aren’t important enough to be errors, so are off by default. Debug logs are incredibly spammy and should only be turned on when debugging a specific issue in the Network Next SDK.</p>
<p>How you handle each of these log levels in the log function callback is up to you. We just pass them in, but depending on the log level we will not call the callback unless the level of the log is &lt;= the current log level value set.</p>
<p>Finally, there is a small feature where a log with NEXT_LOG_LEVEL_NONE is used to indicate an unadorned regular printf. This is useful for console platforms like XBoxOne where hoops need to be jumped through just to get text printed to stdout. This is used by our unit tests and by the default assert handler function in the Network Next SDK.</p>
<p>Next we define a custom assert handler:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">assert_function</span><span class="p">(</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">condition</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">function</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">file</span><span class="p">,</span> <span class="kt">int</span> <span class="n">line</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="n">next_printf</span><span class="p">(</span> <span class="n">NEXT_LOG_LEVEL_NONE</span><span class="p">,</span> <span class="s">&quot;assert failed: ( %s ), function %s, file %s, line %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">condition</span><span class="p">,</span> <span class="n">function</span><span class="p">,</span> <span class="n">file</span><span class="p">,</span> <span class="n">line</span> <span class="p">);</span>
    <span class="n">fflush</span><span class="p">(</span> <span class="n">stdout</span> <span class="p">);</span>
    <span class="cp">#if defined(_MSC_VER)</span>
        <span class="n">__debugbreak</span><span class="p">();</span>
    <span class="cp">#elif defined(__ORBIS__)</span>
        <span class="n">__builtin_trap</span><span class="p">();</span>
    <span class="cp">#elif defined(__clang__)</span>
        <span class="n">__builtin_debugtrap</span><span class="p">();</span>
    <span class="cp">#elif defined(__GNUC__)</span>
        <span class="n">__builtin_trap</span><span class="p">();</span>
    <span class="cp">#elif defined(linux) || defined(__linux) || defined(__linux__) || defined(__APPLE__)</span>
        <span class="n">raise</span><span class="p">(</span><span class="n">SIGTRAP</span><span class="p">);</span>
    <span class="cp">#else</span>
        <span class="cp">#error &quot;asserts not supported on this platform!&quot;</span>
    <span class="cp">#endif</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Here we print out the assert message and force a break. Again, typically you would override this to point to your own assert handler in your game. The code above actually corresponds exactly to our default handler, so you can see what we do if you choose to not override it.</p>
<p>Now instead of sending zero byte packets, let’s send some packets with real intent.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">generate_packet</span><span class="p">(</span> <span class="kt">uint8_t</span> <span class="o">*</span> <span class="n">packet_data</span><span class="p">,</span> <span class="kt">int</span> <span class="o">&amp;</span> <span class="n">packet_bytes</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="n">packet_bytes</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="p">(</span> <span class="n">rand</span><span class="p">()</span> <span class="o">%</span> <span class="n">NEXT_MTU</span> <span class="p">);</span>
    <span class="k">const</span> <span class="kt">int</span> <span class="n">start</span> <span class="o">=</span> <span class="n">packet_bytes</span> <span class="o">%</span> <span class="mi">256</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">packet_bytes</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span> <span class="p">)</span>
        <span class="n">packet_data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint8_t</span><span class="p">)</span> <span class="p">(</span> <span class="n">start</span> <span class="o">+</span> <span class="n">i</span> <span class="p">)</span> <span class="o">%</span> <span class="mi">256</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">verify_packet</span><span class="p">(</span> <span class="k">const</span> <span class="kt">uint8_t</span> <span class="o">*</span> <span class="n">packet_data</span><span class="p">,</span> <span class="kt">int</span> <span class="n">packet_bytes</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="k">const</span> <span class="kt">int</span> <span class="n">start</span> <span class="o">=</span> <span class="n">packet_bytes</span> <span class="o">%</span> <span class="mi">256</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">packet_bytes</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span> <span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span> <span class="n">packet_data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="p">(</span><span class="kt">uint8_t</span><span class="p">)</span> <span class="p">(</span> <span class="p">(</span> <span class="n">start</span> <span class="o">+</span> <span class="n">i</span> <span class="p">)</span> <span class="o">%</span> <span class="mi">256</span> <span class="p">)</span> <span class="p">)</span>
        <span class="p">{</span>
            <span class="n">printf</span><span class="p">(</span> <span class="s">&quot;%d: %d != %d (%d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">packet_data</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="p">(</span> <span class="n">start</span> <span class="o">+</span> <span class="n">i</span> <span class="p">)</span> <span class="o">%</span> <span class="mi">256</span><span class="p">,</span> <span class="n">packet_bytes</span> <span class="p">);</span>
        <span class="p">}</span>
        <span class="n">next_assert</span><span class="p">(</span> <span class="n">packet_data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="p">(</span><span class="kt">uint8_t</span><span class="p">)</span> <span class="p">(</span> <span class="p">(</span> <span class="n">start</span> <span class="o">+</span> <span class="n">i</span> <span class="p">)</span> <span class="o">%</span> <span class="mi">256</span> <span class="p">)</span> <span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The functions above generate packets of random length from 1 to the maximum size packet that can be sent across Network Next – NEXT_MTU (1300 bytes). These packets have contents that can be inferred by the size of the packet, making it possible for us to test a packet and with high probability, ensure that the packet has not been incorrectly truncated or padded, and that it contains the exact bytes sent.</p>
<p>Now we are ready to set a custom log level, set our custom log function, allocators and assert handler.</p>
<p>Before initializing Network Next, do this:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">next_log_level</span><span class="p">(</span> <span class="n">NEXT_LOG_LEVEL_INFO</span> <span class="p">);</span>

<span class="n">next_log_function</span><span class="p">(</span> <span class="n">log_function</span> <span class="p">);</span>

<span class="n">next_assert_function</span><span class="p">(</span> <span class="n">assert_function</span> <span class="p">);</span>

<span class="n">next_allocator</span><span class="p">(</span> <span class="n">malloc_function</span><span class="p">,</span> <span class="n">free_function</span> <span class="p">);</span>
</pre></div>
</div>
<p>Next, create a global context and pass it in to <em>next_init</em> to be used for any global allocations made by the Network Next SDK:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">Context</span> <span class="n">global_context</span><span class="p">;</span>
<span class="n">global_context</span><span class="p">.</span><span class="n">allocator</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">global_allocator</span><span class="p">;</span>

<span class="n">next_config_t</span> <span class="n">config</span><span class="p">;</span>
<span class="n">next_default_config</span><span class="p">(</span> <span class="o">&amp;</span><span class="n">config</span> <span class="p">);</span>
<span class="n">strncpy</span><span class="p">(</span> <span class="n">config</span><span class="p">.</span><span class="n">customer_public_key</span><span class="p">,</span> <span class="n">customer_public_key</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">config</span><span class="p">.</span><span class="n">customer_public_key</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span> <span class="p">);</span>
</pre></div>
</div>
<p>Now when the Network Next SDK makes any global allocations, they will be made by calling the malloc_function and free_function callbacks, passing in the global context pointer as a void*.</p>
<p>Next, create a per-client context and pass it in as the context when creating the client:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">Allocator</span> <span class="n">client_allocator</span><span class="p">;</span>
<span class="n">ClientContext</span> <span class="n">client_context</span><span class="p">;</span>
<span class="n">client_context</span><span class="p">.</span><span class="n">allocator</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">client_allocator</span><span class="p">;</span>
<span class="n">client_context</span><span class="p">.</span><span class="n">client_data</span> <span class="o">=</span> <span class="mh">0x12345</span><span class="p">;</span>

<span class="n">next_client_t</span> <span class="o">*</span> <span class="n">client</span> <span class="o">=</span> <span class="n">next_client_create</span><span class="p">(</span> <span class="o">&amp;</span><span class="n">client_context</span><span class="p">,</span> <span class="n">bind_address</span><span class="p">,</span> <span class="n">client_packet_received</span><span class="p">,</span> <span class="nb">NULL</span> <span class="p">);</span>
<span class="k">if</span> <span class="p">(</span> <span class="n">client</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span> <span class="s">&quot;error: failed to create client</span><span class="se">\n</span><span class="s">&quot;</span> <span class="p">);</span>
    <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Now when the client makes any allocations, and when it calls callbacks like <em>packet_received</em> it will pass in the client context as a void*.</p>
<p>Since we are binding the client to port 0, the system will choose the actual port number. We can retrieve this port number as follows and print it out for posterity:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">uint16_t</span> <span class="n">client_port</span> <span class="o">=</span> <span class="n">next_client_port</span><span class="p">(</span> <span class="n">client</span> <span class="p">);</span>

<span class="n">next_printf</span><span class="p">(</span> <span class="n">NEXT_LOG_LEVEL_INFO</span><span class="p">,</span> <span class="s">&quot;client port is %d&quot;</span><span class="p">,</span> <span class="n">client_port</span> <span class="p">);</span>
</pre></div>
</div>
<p>Finally, the client has been extended to print out all the useful stats you can retrieve from a network next client, once every ten seconds:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">accumulator</span> <span class="o">+=</span> <span class="n">delta_time</span><span class="p">;</span>

<span class="k">if</span> <span class="p">(</span> <span class="n">accumulator</span> <span class="o">&gt;</span> <span class="mf">10.0</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="n">accumulator</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span>

    <span class="n">printf</span><span class="p">(</span> <span class="s">&quot;================================================================</span><span class="se">\n</span><span class="s">&quot;</span> <span class="p">);</span>

    <span class="n">printf</span><span class="p">(</span> <span class="s">&quot;Client Stats:</span><span class="se">\n</span><span class="s">&quot;</span> <span class="p">);</span>

    <span class="k">const</span> <span class="n">next_client_stats_t</span> <span class="o">*</span> <span class="n">stats</span> <span class="o">=</span> <span class="n">next_client_stats</span><span class="p">(</span> <span class="n">client</span> <span class="p">);</span>

    <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">platform</span> <span class="o">=</span> <span class="s">&quot;unknown&quot;</span><span class="p">;</span>

    <span class="k">switch</span> <span class="p">(</span> <span class="n">stats</span><span class="o">-&gt;</span><span class="n">platform_id</span> <span class="p">)</span>
    <span class="p">{</span>
        <span class="k">case</span> <span class="nl">NEXT_PLATFORM_WINDOWS</span><span class="p">:</span>
            <span class="n">platform</span> <span class="o">=</span> <span class="s">&quot;windows&quot;</span><span class="p">;</span>
            <span class="k">break</span><span class="p">;</span>

        <span class="k">case</span> <span class="nl">NEXT_PLATFORM_MAC</span><span class="p">:</span>
            <span class="n">platform</span> <span class="o">=</span> <span class="s">&quot;mac&quot;</span><span class="p">;</span>
            <span class="k">break</span><span class="p">;</span>

        <span class="k">case</span> <span class="nl">NEXT_PLATFORM_LINUX</span><span class="p">:</span>
            <span class="n">platform</span> <span class="o">=</span> <span class="s">&quot;linux&quot;</span><span class="p">;</span>
            <span class="k">break</span><span class="p">;</span>

        <span class="k">case</span> <span class="nl">NEXT_PLATFORM_SWITCH</span><span class="p">:</span>
            <span class="n">platform</span> <span class="o">=</span> <span class="s">&quot;nintendo switch&quot;</span><span class="p">;</span>
            <span class="k">break</span><span class="p">;</span>

        <span class="k">case</span> <span class="nl">NEXT_PLATFORM_PS4</span><span class="p">:</span>
            <span class="n">platform</span> <span class="o">=</span> <span class="s">&quot;ps4&quot;</span><span class="p">;</span>
            <span class="k">break</span><span class="p">;</span>

        <span class="k">case</span> <span class="nl">NEXT_PLATFORM_IOS</span><span class="p">:</span>
            <span class="n">platform</span> <span class="o">=</span> <span class="s">&quot;ios&quot;</span><span class="p">;</span>
            <span class="k">break</span><span class="p">;</span>

        <span class="k">case</span> <span class="nl">NEXT_PLATFORM_XBOX_ONE</span><span class="p">:</span>
            <span class="n">platform</span> <span class="o">=</span> <span class="s">&quot;xbox one&quot;</span><span class="p">;</span>
            <span class="k">break</span><span class="p">;</span>

        <span class="k">default</span><span class="o">:</span>
            <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">state</span> <span class="o">=</span> <span class="s">&quot;???&quot;</span><span class="p">;</span>

    <span class="k">const</span> <span class="kt">int</span> <span class="n">client_state</span> <span class="o">=</span> <span class="n">next_client_state</span><span class="p">(</span> <span class="n">client</span> <span class="p">);</span>

    <span class="k">switch</span> <span class="p">(</span> <span class="n">client_state</span> <span class="p">)</span>
    <span class="p">{</span>
        <span class="k">case</span> <span class="nl">NEXT_CLIENT_STATE_CLOSED</span><span class="p">:</span>
            <span class="n">state</span> <span class="o">=</span> <span class="s">&quot;closed&quot;</span><span class="p">;</span>
            <span class="k">break</span><span class="p">;</span>

        <span class="k">case</span> <span class="nl">NEXT_CLIENT_STATE_OPEN</span><span class="p">:</span>
            <span class="n">state</span> <span class="o">=</span> <span class="s">&quot;open&quot;</span><span class="p">;</span>
            <span class="k">break</span><span class="p">;</span>

        <span class="k">case</span> <span class="nl">NEXT_CLIENT_STATE_ERROR</span><span class="p">:</span>
            <span class="n">state</span> <span class="o">=</span> <span class="s">&quot;error&quot;</span><span class="p">;</span>
            <span class="k">break</span><span class="p">;</span>

        <span class="k">default</span><span class="o">:</span>
            <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">printf</span><span class="p">(</span> <span class="s">&quot; + State = %s (%d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="n">client_state</span> <span class="p">);</span>

    <span class="n">printf</span><span class="p">(</span> <span class="s">&quot; + Session Id = %&quot;</span> <span class="n">PRIx64</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">next_client_session_id</span><span class="p">(</span> <span class="n">client</span> <span class="p">)</span> <span class="p">);</span>

    <span class="n">printf</span><span class="p">(</span> <span class="s">&quot; + Platform = %s (%d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">platform</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="n">stats</span><span class="o">-&gt;</span><span class="n">platform_id</span> <span class="p">);</span>

    <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">connection</span> <span class="o">=</span> <span class="s">&quot;unknown&quot;</span><span class="p">;</span>

    <span class="k">switch</span> <span class="p">(</span> <span class="n">stats</span><span class="o">-&gt;</span><span class="n">connection_type</span> <span class="p">)</span>
    <span class="p">{</span>
        <span class="k">case</span> <span class="nl">NEXT_CONNECTION_TYPE_WIRED</span><span class="p">:</span>
            <span class="n">connection</span> <span class="o">=</span> <span class="s">&quot;wired&quot;</span><span class="p">;</span>
            <span class="k">break</span><span class="p">;</span>

        <span class="k">case</span> <span class="nl">NEXT_CONNECTION_TYPE_WIFI</span><span class="p">:</span>
            <span class="n">connection</span> <span class="o">=</span> <span class="s">&quot;wifi&quot;</span><span class="p">;</span>
            <span class="k">break</span><span class="p">;</span>

        <span class="k">case</span> <span class="nl">NEXT_CONNECTION_TYPE_CELLULAR</span><span class="p">:</span>
            <span class="n">connection</span> <span class="o">=</span> <span class="s">&quot;cellular&quot;</span><span class="p">;</span>
            <span class="k">break</span><span class="p">;</span>

        <span class="k">default</span><span class="o">:</span>
            <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">printf</span><span class="p">(</span> <span class="s">&quot; + Connection = %s (%d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">connection</span><span class="p">,</span> <span class="n">stats</span><span class="o">-&gt;</span><span class="n">connection_type</span> <span class="p">);</span>

    <span class="n">printf</span><span class="p">(</span> <span class="s">&quot; + Committed = %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">stats</span><span class="o">-&gt;</span><span class="n">committed</span> <span class="o">?</span> <span class="s">&quot;yes&quot;</span> <span class="o">:</span> <span class="s">&quot;no&quot;</span> <span class="p">);</span>

    <span class="n">printf</span><span class="p">(</span> <span class="s">&quot; + Multipath = %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">stats</span><span class="o">-&gt;</span><span class="n">multipath</span> <span class="o">?</span> <span class="s">&quot;yes&quot;</span> <span class="o">:</span> <span class="s">&quot;no&quot;</span> <span class="p">);</span>

    <span class="n">printf</span><span class="p">(</span> <span class="s">&quot; + Flagged = %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">stats</span><span class="o">-&gt;</span><span class="n">flagged</span> <span class="o">?</span> <span class="s">&quot;yes&quot;</span> <span class="o">:</span> <span class="s">&quot;no&quot;</span> <span class="p">);</span>

    <span class="n">printf</span><span class="p">(</span> <span class="s">&quot; + Direct RTT = %.2fms</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">stats</span><span class="o">-&gt;</span><span class="n">direct_min_rtt</span> <span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span> <span class="s">&quot; + Direct Jitter = %.2fms</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">stats</span><span class="o">-&gt;</span><span class="n">direct_jitter</span> <span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span> <span class="s">&quot; + Direct Packet Loss = %.1f%%</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">stats</span><span class="o">-&gt;</span><span class="n">direct_packet_loss</span> <span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span> <span class="n">stats</span><span class="o">-&gt;</span><span class="n">next</span> <span class="p">)</span>
    <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span> <span class="s">&quot; + Next RTT = %.2fms</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">stats</span><span class="o">-&gt;</span><span class="n">next_min_rtt</span> <span class="p">);</span>
        <span class="n">printf</span><span class="p">(</span> <span class="s">&quot; + Next Jitter = %.2fms</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">stats</span><span class="o">-&gt;</span><span class="n">next_jitter</span> <span class="p">);</span>
        <span class="n">printf</span><span class="p">(</span> <span class="s">&quot; + Next Packet Loss = %.1f%%</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">stats</span><span class="o">-&gt;</span><span class="n">next_packet_loss</span> <span class="p">);</span>
        <span class="n">printf</span><span class="p">(</span> <span class="s">&quot; + Next Bandwidth Up = %.1fkbps</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">stats</span><span class="o">-&gt;</span><span class="n">next_kbps_up</span> <span class="p">);</span>
        <span class="n">printf</span><span class="p">(</span> <span class="s">&quot; + Next Bandwidth Down = %.1fkbps</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">stats</span><span class="o">-&gt;</span><span class="n">next_kbps_down</span> <span class="p">);</span>
    <span class="p">}</span>

    <span class="n">printf</span><span class="p">(</span> <span class="s">&quot;================================================================</span><span class="se">\n</span><span class="s">&quot;</span> <span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Thanks to Jacob Langworthy and the whole crew at Velan Studios for inspiring this example!</p>
</div>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="index.html">Network Next SDK</a></h1>








<h3>Navigation</h3>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="how_it_works.html">How it works</a></li>
<li class="toctree-l1"><a class="reference internal" href="getting_started.html">Getting Started</a></li>
<li class="toctree-l1"><a class="reference internal" href="building_the_sdk.html">Building the SDK</a></li>
<li class="toctree-l1"><a class="reference internal" href="simple_client_example.html">Simple Client Example</a></li>
<li class="toctree-l1"><a class="reference internal" href="simple_server_example.html">Simple Server Example</a></li>
<li class="toctree-l1"><a class="reference internal" href="upgraded_client_example.html">Upgraded Client Example</a></li>
<li class="toctree-l1"><a class="reference internal" href="upgraded_server_example.html">Upgraded Server Example</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Complex Client Example</a></li>
<li class="toctree-l1"><a class="reference internal" href="complex_server_example.html">Complex Server Example</a></li>
<li class="toctree-l1"><a class="reference internal" href="reference.html">Reference</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="index.html">Documentation overview</a><ul>
      <li>Previous: <a href="upgraded_server_example.html" title="previous chapter">Upgraded Server Example</a></li>
      <li>Next: <a href="complex_server_example.html" title="next chapter">Complex Server Example</a></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2020, Network Next, Inc..
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 3.0.3</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="_sources/complex_client_example.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>